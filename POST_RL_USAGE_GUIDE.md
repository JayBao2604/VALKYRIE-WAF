# Advanced Post-RL Payload Validator - Usage Guide

## Overview

The **AdvancedPostRLAgent** is a production-grade payload quality assurance system designed to validate, correct, and optimize payloads generated by RL/LLM models. It ensures that all generated payloads meet strict requirements for:

1. **Syntactic Correctness** - Perfect adherence to attack grammar
2. **Functional Validity** - Payload can execute the intended attack
3. **WAF Bypass Capability** - Effective evasion techniques preserved
4. **Real-World Applicability** - Production-ready for actual testing

## Key Features

### 1. Strict Grammar Validation
- Validates payload structure against formal grammar rules from `data/grammars/`
- Detects critical (unfixable), high (correctable), medium, and low severity errors
- Supports SQLi, XSS, RCE, XXE, SSRF, NoSQL Injection

### 2. Intelligent Error Correction
- Automatically fixes critical syntax errors (quote balancing, tag closure, etc.)
- Preserves obfuscation techniques discovered by RL
- Only corrects CRITICAL errors that prevent payload execution

### 3. WAF Evasion Analysis
- Identifies 15+ evasion techniques (encoding, comments, case variation, etc.)
- Calculates evasion score based on obfuscation methods used
- Detects polyglot capability for multi-platform bypass

### 4. Semantic Analysis
- Analyzes payload attack methods (boolean-based, union-based, time-based, etc.)
- Verifies data extraction capability for SQLi
- Verifies command execution capability for RCE

### 5. Multi-Dimensional Scoring
- **Grammar Score** (35%): Syntax correctness
- **Reward Score** (35%): RL model evaluation
- **Evasion Score** (15%): WAF bypass capability
- **Semantic Score** (15%): Attack feasibility
- **Combined Score**: Comprehensive payload quality rating

### 6. Production Readiness Classification
Payloads are classified as:
- **EXCELLENT** (â‰¥0.85): Highly optimized, all criteria met
- **GOOD** (â‰¥0.70): Production-ready, minor issues
- **ACCEPTABLE** (â‰¥0.50): Can use with caution
- **POOR** (<0.50): Not recommended

## Installation

```bash
# Install required dependencies
pip install torch transformers tqdm

# Ensure grammar files exist
ls -la data/grammars/
```

## Quick Start

### Basic Usage

```python
from advanced_post_rl_agent import AdvancedPostRLAgent

# Initialize agent
agent = AdvancedPostRLAgent(
    attack_type="sqli",
    min_combined_score=0.70,  # Only accept payloads with score >= 0.70
    device="cpu"  # or "cuda" for GPU
)

# Validate single payload
result = agent.validate_payload("1' OR '1'='1")

# Check if production-ready
if result.is_production_ready:
    print(f"âœ“ Production ready: {result.corrected_payload}")
else:
    print(f"âœ— Rejected: {result.rejection_reasons}")

# Print results
print(f"Combined Score: {result.quality_score.combined_score:.4f}")
print(f"Quality Level: {result.quality_score.quality_level.value}")
```

### Batch Processing

```python
# Process multiple payloads at once
payloads = [
    "1' OR '1'='1",
    "1' UNION SELECT * FROM users --",
    "admin' OR 1=1 --",
    "1' AND SLEEP(5) --",
]

results = agent.process_batch(payloads, verbose=True)

# Print summary
agent.print_summary()

# Export production-ready payloads
agent.export_production_ready("outputs/production_payloads.json")
```

### Using Reward Model

```python
# Initialize with trained reward model
agent = AdvancedPostRLAgent(
    attack_type="sqli",
    reward_model_path="models/reward-models/opt125m-reward_sqli",
    min_combined_score=0.70,
    device="cuda"
)

# Process payloads with real reward scores
results = agent.process_batch(generated_payloads)
```

## Understanding Results

### Validation Result Structure

```python
result = agent.validate_payload(payload)

# Original vs Corrected
print(result.original_payload)     # Original RL output
print(result.corrected_payload)    # After corrections

# Syntax Validation
print(result.syntax_check.is_valid)           # True/False
print(result.syntax_check.critical_errors)    # Count of critical errors

# WAF Evasion
print(result.waf_evasion.obfuscation_techniques)  # List of techniques
print(result.waf_evasion.evasion_score)           # Score 0-1

# Quality Scores (breakdown)
scores = result.quality_score
print(f"Grammar:  {scores.grammar_score:.4f}")
print(f"Reward:   {scores.reward_score:.4f}")
print(f"Evasion:  {scores.evasion_score:.4f}")
print(f"Semantic: {scores.semantic_score:.4f}")
print(f"Combined: {scores.combined_score:.4f}")

# Production Status
print(result.is_production_ready)      # True/False
print(result.rejection_reasons)        # Why rejected (if any)

# JSON Export
print(result.to_dict())
```

## Configuration Guide

### Attack Types Supported

| Attack Type | Validation Focus | Evasion Techniques |
|-----------|-------------------|-------------------|
| **sqli** | Quote balance, injection markers, comment closure | URL encoding, case variation, comment injection |
| **xss** | Tag balance, event handlers, script closure | HTML entities, unicode escape, tag spacing |
| **rce** | Command separators, quote balance, paren closure | String concat, base64, variable substitution |
| **xxe** | XML structure, entity declarations, tag balance | HTML entities, parameter entities |
| **ssrf** | URL scheme, format validation | IP shorthand, hex encoding, bypass techniques |
| **nosqli** | Brace/bracket balance, MongoDB operators | Encoding, operator obfuscation |

### Scoring Weights

Adjust the Combined Score formula in `AdvancedPostRLAgent.validate_payload()`:

```python
# Current weights (default)
combined_score = (
    grammar_score * 0.35 +   # Syntax correctness
    reward_score * 0.35 +    # RL model score
    evasion_score * 0.15 +   # WAF bypass capability
    semantic_score * 0.15    # Attack feasibility
)

# Example: Prioritize WAF evasion
combined_score = (
    grammar_score * 0.30 +
    reward_score * 0.30 +
    evasion_score * 0.25 +   # Higher weight
    semantic_score * 0.15
)
```

### Minimum Score Threshold

```python
# Stricter validation - only "good" quality payloads
agent = AdvancedPostRLAgent(
    attack_type="sqli",
    min_combined_score=0.75  # 75%
)

# Lenient validation - accept "acceptable" quality
agent = AdvancedPostRLAgent(
    attack_type="sqli",
    min_combined_score=0.50  # 50%
)
```

## Advanced Usage

### Custom Error Correction Logic

```python
from advanced_post_rl_agent import IntelligentPayloadCorrector

corrector = IntelligentPayloadCorrector(agent.grammar_validator)

# Manually correct critical errors
payload = "1' OR '1'='1"  # Missing comment
syntax_check = agent.grammar_validator.validate_comprehensive(payload)
corrected, fixes = corrector.correct_critical_errors(payload, syntax_check.errors)

print(f"Fixes applied: {fixes}")
print(f"Corrected: {corrected}")
```

### Custom Scoring

```python
# Use only grammar score (high strictness)
for result in results:
    if result.syntax_check.is_valid:
        print(f"âœ“ Valid: {result.corrected_payload}")

# Use only evasion score (WAF bypass focus)
for result in results:
    if result.waf_evasion.evasion_score > 0.5:
        print(f"âœ“ Good WAF evasion: {result.corrected_payload}")

# Use semantic score (attack effectiveness focus)
for result in results:
    if result.semantic_analysis.get("data_extraction_capable"):
        print(f"âœ“ Can extract data: {result.corrected_payload}")
```

### Analyzing WAF Evasion Techniques

```python
evasion = result.waf_evasion

print("Evasion Techniques:")
for tech in evasion.obfuscation_techniques:
    print(f"  - {tech}")

print("\nEncoding Used:")
for encoding in evasion.encoding_used:
    print(f"  - {encoding}")

print(f"\nPolyglot Capable: {evasion.polyglot_capable}")
print(f"Evasion Score: {evasion.evasion_score:.4f}")
```

## Integration with RL Pipeline

### Processing RL-Generated Payloads

```python
from generate_from_RL import generate_payload  # Your RL generation

# Step 1: Generate payloads from RL model
rl_payloads = []
for prompt in attack_prompts:
    payload = generate_payload(prompt)
    rl_payloads.append(payload)

# Step 2: Validate and optimize with PostRL Agent
agent = AdvancedPostRLAgent(
    attack_type="sqli",
    reward_model_path="models/reward-models/opt125m-reward_sqli",
    min_combined_score=0.70
)

optimized_results = agent.process_batch(rl_payloads, verbose=True)

# Step 3: Export production-ready payloads
agent.export_production_ready("outputs/final_payloads.json")

# Step 4: Statistics
stats = agent.get_statistics()
print(f"Production-ready rate: {stats['production_rate_percent']:.2f}%")
print(f"Average combined score: {stats['average_scores']['combined_score']:.4f}")
```

### JSON Export Format

```json
{
  "metadata": {
    "attack_type": "sqli",
    "total_processed": 100,
    "production_ready": 75,
    "production_rate": 0.75,
    "min_combined_score": 0.70
  },
  "statistics": {
    "total_payloads": 100,
    "production_ready": 75,
    "production_rate_percent": 75.0,
    "syntax_valid": 85,
    "syntax_valid_rate_percent": 85.0,
    "quality_distribution": {
      "excellent": 45,
      "good": 30,
      "acceptable": 15,
      "poor": 10
    },
    "average_scores": {
      "grammar_score": 0.92,
      "reward_score": 0.78,
      "evasion_score": 0.65,
      "semantic_score": 0.88,
      "combined_score": 0.81
    }
  },
  "payloads": [
    {
      "payload_hash": "a1b2c3d4e5f6g7h8",
      "original_payload": "1' OR '1'='1",
      "corrected_payload": "1' OR '1'='1 --",
      "syntax_valid": true,
      "syntax_errors": 0,
      "quality_scores": {
        "grammar_score": 1.0,
        "reward_score": 0.85,
        "evasion_score": 0.3,
        "semantic_score": 0.95,
        "combined_score": 0.8275,
        "quality_level": "good"
      },
      "waf_evasion": {
        "has_obfuscation": false,
        "obfuscation_techniques": [],
        "evasion_score": 0.3
      },
      "is_production_ready": true,
      "corrections_applied": []
    }
  ]
}
```

## Performance Considerations

### Batch Processing Speed

```python
# Process large batch efficiently
import time

large_batch = generated_payloads  # 10,000 payloads

start = time.time()
results = agent.process_batch(large_batch, verbose=True)
elapsed = time.time() - start

print(f"Processed {len(results)} payloads in {elapsed:.2f}s")
print(f"Average: {1000*elapsed/len(results):.2f}ms per payload")
```

### GPU Acceleration

```python
# Use GPU for faster scoring (if reward model is available)
agent = AdvancedPostRLAgent(
    attack_type="sqli",
    reward_model_path="models/reward-models/opt125m-reward_sqli",
    device="cuda"  # Switch to CUDA
)

# Processing will be significantly faster
```

## Troubleshooting

### Grammar Validation Errors

**Issue**: "Grammar file not found"
```python
# Solution: Ensure data/grammars/ exists
import os
assert os.path.exists("data/grammars/sqli-grammar.txt"), "Grammar file missing"
```

### Reward Model Issues

**Issue**: "Failed to load reward model"
```python
# Solution: Verify model path and transformers version
agent = AdvancedPostRLAgent(
    attack_type="sqli",
    reward_model_path=None  # Skip reward model
)
# Will use heuristic scoring instead
```

### Low Production Rate

**Issue**: Only 10% of payloads marked as production-ready

```python
# Solution 1: Lower the threshold
agent.min_combined_score = 0.60

# Solution 2: Check syntax validity
for r in agent.results:
    if not r.syntax_check.is_valid:
        print(f"Syntax errors: {r.syntax_check.errors}")

# Solution 3: Check semantic validity
for r in agent.results:
    if not r.semantic_analysis.get("data_extraction_capable"):
        print(f"Cannot extract data: {r.corrected_payload}")
```

## Example: Complete Pipeline

```python
from advanced_post_rl_agent import AdvancedPostRLAgent

# Configuration
ATTACK_TYPE = "sqli"
REWARD_MODEL = "models/reward-models/opt125m-reward_sqli"
OUTPUT_FILE = "outputs/production_payloads.json"
MIN_SCORE = 0.70

# 1. Initialize agent
print("ðŸš€ Initializing Post-RL Validator...")
agent = AdvancedPostRLAgent(
    attack_type=ATTACK_TYPE,
    reward_model_path=REWARD_MODEL,
    min_combined_score=MIN_SCORE,
    device="cuda" if torch.cuda.is_available() else "cpu"
)

# 2. Load RL-generated payloads
print("ðŸ“¥ Loading generated payloads...")
with open("rl_generated_payloads.txt", "r") as f:
    payloads = [line.strip() for line in f]

print(f"Processing {len(payloads)} payloads...")

# 3. Validate and optimize
results = agent.process_batch(payloads, verbose=True)

# 4. Print comprehensive report
agent.print_summary()

# 5. Export production-ready payloads
agent.export_production_ready(OUTPUT_FILE)

print(f"âœ“ Results saved to {OUTPUT_FILE}")
```

## References

- **Grammar Files**: `data/grammars/{sqli,xss,rce,xxe,ssrf,nosqli}-grammar.txt`
- **Reward Model**: Trained with A2C/GAE from RL pipeline
- **Validation Levels**: CRITICAL > HIGH > MEDIUM > LOW
- **Quality Levels**: EXCELLENT > GOOD > ACCEPTABLE > POOR
